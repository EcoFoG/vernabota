---
title: "Using the package vernabota"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Using_vernabota}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
bibliography: ../vignettes/REFERENCES.bib  
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

This document describes the methods and use of the package *vernabota* to gapfill missing botanical names using vernacular names, in the case of Guyafor census data.
The objective is to obtain a chosen number of simulated communities for which individuals only identified with a vernacular name are given a botanical name based on probabilities of association of vernacular and botanical names.
It is largely based on the work and codes from @Aubry-Kientz2013 and @Mirabel2018a.

# Method of association of a vernacular name with a botanical name

Be a tree *t* with a vernacular name *v*. 
This tree can have a known genus, only a known family or no botanical information at all.
The associated botanical names follow a categorical distribution *$\mathcal{Cat} (\alpha^v)$* 
where $\alpha^v = [\alpha^v_1, \alpha^v_2,..., \alpha^v_N]$  is the vector of probability of association of between the vernacular name *v* and each botanical name (so $\sum_{s=1}^N \alpha^v_i =1)$)
and N is the number of botanical name present in the inventories taken as a reference and/or the prior knowledge.

To get the vector $\alpha^v$, we use a Dirichlet-categorical scheme to combine a prior information based on expert knowledge that we updated with observed frequencies of association between the vernacular name *v* and each botanical name in the reference inventories $f^v = [f^v_1, f^v_2,..., f^v_N]$.

We considered $\lambda^v$ as hyperparameters of $\alpha^v$, *i.e.* the parameters of the prior distribution of $\alpha^v$.
The prior probability of association of the vernacular *v* with each botanical name *s* in [1,N] is $\lambda^v_s$ and is obtained as follows:

  * $\lambda^v_s = \frac{1}{m_v}$ if the botanical name *s* is associated to the vernacular name *v* AND belongs to the same genus than *t* (if there is a know genus) and the same family than *t* (if there is a known family). 
  $m_v$ is the number of botanical names meeting these conditions.
  * $\lambda^v_s = \frac{\epsilon}{N-m_v}$ otherwise ($\epsilon$ being a background noise)

The prior distribution of $\alpha^v \sim \mathcal{Dir}(N, \lambda^v)$.

As the Dirichlet distribution is the conjugated prior of the categorical distribution, the posterior distribution of the probabilities of associations $\alpha^v$ can be obtained by updating the expert knowledge with the observed frequency of association $f^v$.

So the posterior distribution of probability of association is $\alpha^v | f^v,\lambda^v  \sim \mathcal{Dir} (N, w_p \times \lambda^v_1 + (1-w_p) \times f^v_1,...,w_p \times \lambda^v_N+(1-w_p) \times f^v_N)$
where $w_p$ is the weigth given to the prior information. 

NB: $\lambda^v$ and $f^v$ are taken as frequencies to give the same weight to give the same weight to the prior and the observations when given an equal weight (*i.e.* when $w_p=0.5$. 


**In practice**, as we don't want to calculate the vector $\alpha^v$ for each tree, we create a matrix $\alpha$ of $\alpha^v$ that will be used for all trees.
We therefore don't have any information at this stage.
we take $\lambda^v_s = 0$ for the botanical names that are not associated to the vernacular name *v* according to expert knowledge.
The matrix $\alpha$ have a lot of 0 (in case when there is no association according to expert knowledge, nor according to the data).
When we then consider the tree *t*, we replace non-null values by 0 when botanical names don't belong to the same genus than *t* (if there is a know genus) and the same family than *t* (if there is a known family).
We then replace 0 by epsilon divided by the number of value=0.


# Installing and loading the package

Before the first use, the package needs to be installed from GitHub:

```{r install, eval=FALSE}
devtools::install_github("EcoFoG/vernabota", build_vignettes = TRUE)
```

It can then be loaded.

```{r setup}
library(vernabota)
```

```{r setseed, echo=FALSE}
set.seed(56)
```


# Preparing the data

## Data that we want to gapfill

This algorithm works on a dataset formatted as it is when obtained using the function *EcoFoG::Guyafor2df* or from the online data plateform of Paracou.

Here, we take the example of data from plot 6, census of 2016, and use subplot 1 as the dataset that we want to gapfill. 
We call this dataset *Data2fill*.

In this dataset, the column VernName should not contain any special character such as é, è or œ (data from the Guyafor database should not have these special characters).

We use the function *PrepData* to prepare the data.

```{r get data to fill}
data(Paracou6_2016)
Data2fill <- Paracou6_2016[Paracou6_2016$SubPlot==1,]
Data2fill <- PrepData(Data2fill)
str(Data2fill)
```

## Prior: expert knowledge on possible associations

> A FAIRE

The prior is a data.frame with vernacular names in columns and botanical names in rows (given in 3 column Family, Genus and Species. 
For a given vernacular name and a given botanical name, the value is 1 if the association is possible, according to expert knowledge, and 0 if not.

## Observation data to update the prior

To built the matrix of association between vernacular and scientific names, we can either use the same dataset than the one for which we want to perform the association or another dataset.
The user needs to carefully think this choice through.
Using the same dataset can lead to underestimating diversity as it consider that there cannot be any dispersal of species from outside.
Using a too wide data set could lead to associating species that are not present in the area.

In this dataset, the column VernName should not contain any special character such as é, è or œ (data from the Guyafor database should not have these special characters).

Here, we use data from plot 6 (all four subplots), census of 2016.
We call this dataset *DataAsso*.

We use the function *PrepData* to prepare the data.

```{r get data for asso}
DataAsso <- Paracou6_2016
DataAsso <- PrepData(DataAsso)
str(DataAsso)
```


# Running some simmulations using the function SimFullCom

## Example 1: using the same dataset for Data2fill and DataAsso, without prior

## Example 2: using different dataset for Data2fill and DataAsso, without prior

## Example 3: using different dataset for Data2fill and DataAsso, with a prior (same weighing of the prior and the observation)

## Example 4: using different dataset for Data2fill and DataAsso, with a prior (different weighing of the prior and the observation)

## Example 5: getting the more likely associations (using Determ=TRUE)



# Comparing different setting for the simulations using the function CompareSim

*NB*: for these examples, a low number of simulation is used.
For real test, a higher number of simulations should be performed.

## Comparing different observation data

Here we compare two scenario:

* the observation used to update the prior are the same than the data that we want to gapfill

* the observation used to update the prior are different than data that we want to gapfill

```{r Compare1, eval=FALSE}
Param <- data.frame(priors = c(1,1),
                    dataFill = c(1,1),
                    dataAsso = c(1,2),
                    weights = c(0.5,0.5),
                    NbSim = c(5,5),
                    pc2fill = c(10,10),
                    pcFamilyDet = c(25,25),
                    pcGenusDet = c(25,25),
                    eps = c(0.01,0.01),
                    Determ = c(F,F),
                    Results_Simulations = c(F,F))

D2fill <- list(Data2fill[1:5000,])

DAsso <- D2fill
## GD: plus besoin d'appeller les weights comme une liste car tu les as mis dans Param
#weights <- list(0.5)


sp_tot <- paste(D2fill[[1]]$Family, D2fill[[1]]$Genus, D2fill[[1]]$Species, sep="_")
prior <- matrix(data= sample(c(0,1), size=length(unique(sp_tot))*length(unique(D2fill[[1]]$VernName)), replace = TRUE), nrow=length(unique(sp_tot)), ncol=length(unique(D2fill[[1]]$VernName)))
colnames(prior) <- unique(D2fill[[1]]$VernName)
prior <- cbind(data.frame(Family = unlist(strsplit(unique(sp_tot),'_'))[seq(from=1,to=length(unlist(strsplit(unique(sp_tot),'_')))-2,by=3)],
                          Genus = unlist(strsplit(unique(sp_tot),'_'))[seq(from=2,to=length(unlist(strsplit(unique(sp_tot),'_')))-1,by=3)],
                          Species = unlist(strsplit(unique(sp_tot),'_'))[seq(from=3,to=length(unlist(strsplit(unique(sp_tot),'_'))),by=3)]),
               prior)
row.names(prior) <- NULL
priors <- list(prior)

set.seed(33)
## GD: j'enlèvre NScenar car je l'ai enlevé de la fonction
VBS_test <- CompareSim(Param = Param ,
                       priors = priors, D2fill = D2fill, DAsso = DAsso)

summary(VBS_test)
plot(VBS_test)
```


## Comparing different priors

## Comparing different prior weight

## Comparing more likely associations with drawn associations

## Checking stability of association accuracy

## Examining wrong associations


# Bibliography
